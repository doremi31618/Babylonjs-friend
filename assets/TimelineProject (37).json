{
	"config": {},
	"scripts": [
		{
			"name": "VolumetricLight",
			"source": [
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"function initVolumeLight(){",
				"\tscene.imageProcessingConfiguration.toneMappingEnabled = true;",
				"\tvar godrays = new BABYLON.VolumetricLightScatteringPostProcess('godrays', 1.0, camera, null, 100, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false);",
				"\tgodrays.samples = 4;",
				"\tgodrays.mesh.material.emissiveColor = new BABYLON.Color3(0,0,0);",
				"\tgodrays.mesh.material.transparencyMode = 0;",
				"\tgodrays.mesh.position = new BABYLON.Vector3(100, 100, 200);",
				"\tgodrays.mesh.scaling = new BABYLON.Vector3(350, 350, 350);",
				"\topenVolumeLight();",
				"",
				"",
				"\t//Ceiling.001",
				"\t// var ceiliing = scene.getMeshByName(\"Ceiling.001\");",
				"\t// ceiliing.visibility = 0;",
				"",
				"",
				"\tfunction closeVolumeLight(){",
				"\t\tgodrays.weight = 0.0;",
				"",
				"\t}",
				"",
				"\tfunction openVolumeLight(){",
				"\t\tgodrays.exposure = 0.1;",
				"\t\tgodrays.decay = 0.96815;",
				"\t\tgodrays.weight = 0.98767;",
				"\t\tgodrays.density = 0.996;",
				"",
				"\t}",
				"",
				"}",
				"//console.log('[VolumeLight] detect fps', engine.getFps().toFixed());",
				"if (app.devicePerformance.tier > 2 && !app.devicePerformance.isMobile )initVolumeLight();"
			]
		},
		{
			"name": "IvyEffect",
			"source": [
				"",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"//const Lawn = scene.getMeshByName(\"Lawn\");",
				"//const IvyWall_L = scene.getMeshByName(\"Ivy Wall_L\");",
				"const Ivy_Wall_R_primitive0 = scene.getMeshByName(\"Ivy Wall_R_primitive0\");",
				"const Ivy_Wall_R_primitive1 = scene.getMeshByName(\"Ivy Wall_R_primitive1\");",
				"//console.log(\"ivywall\",IvyWall_R.material);",
				"if (Ivy_Wall_R_primitive0 && Ivy_Wall_R_primitive1){",
				"\tIvy_Wall_R_primitive0.material.dissolve.isEnabled = true;",
				"\tIvy_Wall_R_primitive0.applyFog = false;",
				"\t",
				"\tIvy_Wall_R_primitive1.material.dissolve.isEnabled = true;",
				"\tIvy_Wall_R_primitive1.applyFog = false;",
				"}else{",
				"console.log(\"Ivy_Wall_R_primitive0\",Ivy_Wall_R_primitive0, \" or Ivy_Wall_R_primitive1\",Ivy_Wall_R_primitive1, \" not found\");",
				"}",
				"",
				"// Lawn.material.dissolve.isEnabled = true;",
				"// const Dissolve = new DissolvePluginMaterial(IvyWall_L.material);",
				"// IvyWall_L.material = ivyMaterial;",
				"// IvyWall_R.material = ivyMaterial;",
				"",
				""
			]
		},
		{
			"name": "LoadModel",
			"source": [
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"loadModel(\"./assets/\", \"Big_file_01.glb\", scene, (event)=>{",
				"\t//console.log(\"load event\", event);",
				"}).then(result=>{",
				"\t//console.log(\"load result\", result);",
				"\tif (result.meshes && result.meshes.length > 0){",
				"\t\tresult.meshes[0].scaling.z = 1;",
				"\t\tresult.meshes[0].scaling.x = -1;",
				"\t}",
				"\t",
				"\tinitLoadingModel(result);",
				"});",
				"",
				"function initLoadingModel(result){",
				"\tfor(var i=1; i<result.meshes.length; i++){",
				"\t\tlet mesh = result.meshes[i];",
				"\t\tmesh.setEnabled(false);",
				"\t",
				"\t}",
				"\t",
				"\tfor(var i=0; i<result.animationGroups.length; i++){",
				"\t\tlet animationGroup = result.animationGroups[i];",
				"\t\tanimationGroup.stop();",
				"\t\tanimationGroup.loopAnimation = false",
				"\t\t//scene.animationGroups.push(animationGroup);",
				"\t",
				"\t}",
				"",
				"}",
				"",
				"function loadModel(filePath,fileName, scene, onProgressCallback){",
				"    return BABYLON.SceneLoader.ImportMeshAsync(\"\", filePath, fileName, scene, (event)=>{",
				"        if (!onProgressCallback)return;",
				"        onProgressCallback(event);",
				"    });",
				"}"
			]
		},
		{
			"name": "ArmillarySystem",
			"source": [
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"class Planets {",
				"    constructor(scene) {",
				"        this.scene = scene;",
				"        this.planetCenter = scene.getTransformNodeByName(\"Planet_Center\");",
				"        this._selectedBall = null;",
				"        this._oldPos = new BABYLON.Vector3(0, 0, 0);",
				"        this._time = 0;",
				"",
				"        this._mode = Planets.MODE_IDLE;",
				"        this.rotateMethod = new Map();",
				"        this.rotateMethod.set(Planets.MODE_IDLE, ()=>{this.generalRotate()});",
				"        this.rotateMethod.set(Planets.MODE_SELECTED, ()=>{this.selectedRoate()});",
				"",
				"    }",
				"    static MODE_IDLE = 0;",
				"    static MODE_SELECTED = 1;",
				"    static transitionTime = 2;",
				"",
				"",
				"    update() {",
				"        this.planetCenter.rotate(new BABYLON.Vector3(0, 1, 0), Math.PI / 400);",
				"        this.rotateMethod.get(this._mode)();",
				"    }",
				"",
				"    generalRotate() {",
				"        // this.planetCenter.rotate(new BABYLON.Vector3(0, 1, 0), Math.PI / 400);",
				"        if (this._selectedBall) {",
				"",
				"            //check if ball back to origin pos",
				"            if (this._oldPos.y - this._selectedBall.position.y <= 0.01) {",
				"                this._selectedBall.position = this._oldPos;",
				"                this._selectedBall = null;",
				"                ",
				"                return;",
				"            }",
				"",
				"            //translate ball to origin pos",
				"            this._selectedBall.position = BABYLON.Vector3.Lerp(BABYLON.Vector3.Zero(), this._oldPos, this._time / Planets.transitionTime);",
				"            this._time += this.scene.deltaTime / 1000;",
				"",
				"        }",
				"    }",
				"",
				"    selectedRoate() {",
				"        // this.planetCenter.rotate(new BABYLON.Vector3(0, 1, 0), Math.PI / 400);",
				"        if (this._time > Planets.transitionTime){",
				"            return;",
				"        }",
				"",
				"        //translate ball to origin pos",
				"        this._selectedBall.position = BABYLON.Vector3.Lerp(this._oldPos, BABYLON.Vector3.Zero(), this._time / Planets.transitionTime);",
				"        this._time += this.scene.deltaTime / 1000;",
				"",
				"",
				"    }",
				"",
				"    switchMode(mode) {",
				"        if (this._mode != mode) {",
				"            console.log(\"planet switch mode\");",
				"            switch (mode) {",
				"                case Planets.MODE_IDLE:",
				"                    this._mode = Planets.MODE_IDLE;",
				"                    this._time = 0;",
				"                    return;",
				"                case Planets.MODE_SELECTED:",
				"                    this._mode = Planets.MODE_SELECTED;",
				"                    const selectedBallName = \"Pano_01\";",
				"                    this._selectedBall = this.scene.getMeshByName(selectedBallName);",
				"                    this._oldPos = new BABYLON.Vector3(",
				"                        this._selectedBall.position.x,",
				"                        this._selectedBall.position.y, ",
				"                        this._selectedBall.position.z);",
				"                    this._time = 0;",
				"                    return;",
				"                default:",
				"                    console.error(\"[ArmillarySystem] no respond mode\")",
				"                    return;",
				"            }",
				"        }",
				"    }",
				"",
				"}",
				"class Armillary {",
				"    constructor(scene) {",
				"        this._layer_name_list = [\"Armillary_transfer_Cylinder_00\", \"Armillary_transfer_Cylinder_01\", \"Armillary_transfer_Cylinder_02\", \"Armillary_transfer_Cylinder_03\"];",
				"        this._layer_list = [];",
				"        for (var layer_name of this._layer_name_list) {",
				"            let layer = scene.getMeshByName(layer_name);",
				"            this._layer_list.push(layer);",
				"        }",
				"",
				"        //init rotate method ",
				"        this._mode = Armillary.MODE_IDLE;",
				"        this._rotation_method = new Map();",
				"        this._rotation_method.set(Armillary.MODE_IDLE, () => (this.generalRotate()));",
				"        this._rotation_method.set(Armillary.MODE_OPEN, () => (this.openRotate()));",
				"",
				"        this.scene = scene;",
				"",
				"    }",
				"",
				"    static MODE_IDLE = 0;",
				"    static MODE_OPEN = 1;",
				"",
				"    static frontSpeed = Math.PI / 800",
				"    static backSpeed = Math.PI / 100;",
				"",
				"    getLayer(index) {",
				"        return this._layer_list[index];",
				"    }",
				"",
				"    update() {",
				"        if (this._layer_list.length <= 0) return;",
				"        // console.log(\"rotation method\",this._rotation_method.get(this._mode));",
				"",
				"        this._rotation_method.get(this._mode)();",
				"    }",
				"",
				"    generalRotate() {",
				"        for (var layer of this._layer_list) {",
				"            layer.rotate(new BABYLON.Vector3(1, 1, 1), Armillary.frontSpeed);",
				"            // console.log(layer.name, layer.rotationQuaternion)",
				"        }",
				"    }",
				"",
				"    openRotate() {",
				"        ",
				"        for (var layer of this._layer_list) {",
				"            if (layer.rotationQuaternion.x == 0) continue;",
				"            //  layer.rotate(new BABYLON.Vector3(1,1,1), -Math.PI/200);",
				"            if (layer.rotationQuaternion.x >= Armillary.backSpeed) layer.rotate(new BABYLON.Vector3(1, 1, 1), -Armillary.backSpeed);",
				"            else if (layer.rotationQuaternion.x <= -Armillary.backSpeed) layer.rotate(new BABYLON.Vector3(1, 1, 1), Armillary.backSpeed);",
				"            else {",
				"\t\t\t\t//console.log(\"RotationAxis\", BABYLON.Quaternion.RotationAxis);",
				"                layer.rotationQuaternion = BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 0, 0), 0);",
				"            };",
				"        }",
				"    }",
				"",
				"    switchMode(mode) {",
				"        if (this._mode != mode) {",
				"            //console.log(\"switch mode\");",
				"            switch (mode) {",
				"                case Armillary.MODE_IDLE:",
				"                    this._mode = Armillary.MODE_IDLE;",
				"                    return;",
				"                case Armillary.MODE_OPEN:",
				"                    this._mode = Armillary.MODE_OPEN;",
				"                    return;",
				"                default:",
				"                    console.error(\"[ArmillarySystem] no respond mode\")",
				"                    return;",
				"            }",
				"        }",
				"    }",
				"",
				"",
				"}",
				"//refernce : https://playground.babylonjs.com/#ILZ46P#13",
				"",
				"",
				"scene.armillary = new Armillary(scene);",
				"scene.planets = new Planets(scene);",
				"",
				"scene.registerBeforeRender(() => {",
				"    scene.armillary.update();",
				"    scene.planets.update();",
				"})",
				"",
				"",
				""
			]
		}
	],
	"effects": [
		{
			"name": "SetCamera_forward",
			"source": [
				"",
				"var parameters = {",
				"\tisForwardMode: new FRAME.Parameters.Boolean( 'isForwardMode', true),};",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"var module = app.getCurrentScene().getModule('pathNavigation');",
				"",
				"if (app.devicePerformance.isMobile) camera.fov = 1.25;",
				"else  camera.fov = 1;",
				"",
				"function start(){",
				"}",
				"",
				"function end(){",
				"//console.log('path control end');",
				"}",
				"",
				"function update( progress ){",
				"\tif (!parameters.isForwardMode)progress = 1-progress;",
				"\t",
				"\t//console.log(\"path control progress\", progress);",
				"\tmodule.moveTo(progress);",
				"\t",
				"}"
			]
		},
		{
			"name": "playStoneAnimation",
			"source": [
				"var parameters = {",
				"\ttype: new FRAME.Parameters.String( 'type', \"group\" ),",
				"\tname: new FRAME.Parameters.String( 'name', \"Stele\" ),",
				"};",
				"",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"function start(){",
				"//console.log(\"play animation\");",
				"\tapp.playAnimation(parameters.type.value, parameters.name.value);",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "SetCamera_back",
			"source": [
				"",
				"var parameters = {",
				"\tisForwardMode: new FRAME.Parameters.Boolean( 'is Forward Mode', false),};",
				"",
				"var app = document.babylonApp;",
				"var scene = app.getCurrentScene();",
				"var babylonscene = scene._scene;",
				"var module = scene.getModule('pathNavigation');",
				"",
				"function start(){",
				"\tconsole.log(\"camera module\", module);",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){",
				"\tif (!parameters.isForwardMode.value)progress = 1-progress;",
				"\tmodule.moveTo(progress);",
				"\t",
				"}"
			]
		},
		{
			"name": "FadeEffect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 ),",
				"\tisFadeIn: new FRAME.Parameters.Boolean( 'is Fade In', true),",
				"\tFadeOutObj: new FRAME.Parameters.String( 'Fadeout object', \"平面\"),",
				"};",
				"",
				"var app = document.babylonApp;",
				"var scene = app.getCurrentScene()._scene;",
				"var fadeout;",
				"",
				"function start(){",
				"\tconsole.log('scene content',scene, \"parameter\", parameters);",
				"\tfadeout = scene.getMeshById(parameters.FadeOutObj.value);",
				"\tconsole.log(\"find out object\", fadeout);",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){",
				"\tconsole.log(\"fadeout\",fadeout);",
				"\tfadeout.visibility = parameters.isFadeIn.value ? progress : 1-progress;",
				"}"
			]
		},
		{
			"name": "DustParticleEffect",
			"source": [
				"",
				"",
				"var parameters = {",
				"};",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"const particleTexture = new BABYLON.Texture(\"./assets/flare.png\", scene);",
				"const dustEffect = createDustParticleEffect();",
				"//dust_particle_system.stop();",
				"",
				"function start(){",
				"\tdustEffect.start();",
				"}",
				"",
				"function end(){",
				"    dustEffect.stop();",
				"}",
				"",
				"function update( progress ){}",
				"",
				"function createDustParticleEffect(){",
				"    let particleSystem = new BABYLON.ParticleSystem(\"Dust\", 30, scene)",
				"    //console.log(\"particle system \",particleSystem)",
				"    particleSystem.particleTexture = particleTexture;",
				"    ",
				"    ",
				"    //setting emission",
				"    // let emitterBox = new BABYLON.CreateBox(\"Dust Emitter\", {size:10}, scene);",
				"    // emitterBox.position = new BABYLON.Vector3(0,2.5,15);",
				"    // emitterBox.rotation = new BABYLON.Vector3(Math.PI/2, Math.PI, 0)",
				"    // emitterBox.visibility = 0;",
				"    particleSystem.emitter = camera;",
				"    particleSystem.emitRate = 10.0;",
				"    particleSystem.minEmitBox = new BABYLON.Vector3(-2,-2,-2);",
				"    particleSystem.maxEmitBox = new BABYLON.Vector3(2,3,15);",
				"",
				"    //setting life time",
				"    particleSystem.minLifeTime = 1.0;",
				"    particleSystem.maxLifeTime = 5.0;",
				"",
				"    //setting color",
				"    // console.log(\"color gradient function\",particleSystem.addColorGradiant);",
				"    particleSystem.addColorGradient(0, new BABYLON.Color4(0,0,0,0), new BABYLON.Color4(0,0,0,0));",
				"    particleSystem.addColorGradient(0.5, new BABYLON.Color4(1,1,1,0.6), new BABYLON.Color4(1,1,1,0.6));",
				"    particleSystem.addColorGradient(1.0, new BABYLON.Color4(0,0,0,1), new BABYLON.Color4(0,0,0,1));",
				"    ",
				"    //emitssion power",
				"    particleSystem.minEmitPower = 0.1;",
				"    particleSystem.maxEmitPower = 0.15;",
				"",
				"    //particle random scale",
				"    particleSystem.minSize = 0.05;",
				"    particleSystem.maxSize = 0.15;",
				"",
				"    particleSystem.direction1 = new BABYLON.Vector3(0,0,-1);",
				"",
				"    particleSystem.stop();",
				"    return particleSystem;",
				"}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "UnderseaEffect",
			"source": [
				"",
				"var parameters = {",
				"\t",
				"};",
				"//https://nme.babylonjs.com/#7X2PUH",
				"//https://www.babylonjs-playground.com/#ZUBF8M#0",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"const initBackgroundColor = scene.clearColor;",
				"const initAmbientColor = scene.ambient;",
				"let causticLight = initCausticLight();",
				"",
				"const causticEffectMeshList = [\"Floor.002\", \"Sand\",  \"Anchor\", \"Seabaed  Rock _All\", \"Railing_SecPillar\", \"Display Stand_Lp\"];",
				"const emissiveMesh = \"Railing_SecPillar\";",
				"let subMeshList = [];",
				"let mainMeshList = [];",
				"",
				"function start(){",
				"    controlFog(true);",
				"    controlWaterPlane(true);",
				"}",
				"",
				"function end(){",
				"    controlFog(false);",
				"    controlWaterPlane(false);",
				"}",
				"",
				"function update( progress ){",
				"    ",
				"}",
				"function initCausticLight(){",
				"",
				"    let light = new BABYLON.SpotLight(\"causticLight\", new BABYLON.Vector3(0, 3, 0), new BABYLON.Vector3(0, -1, 0), BABYLON.Tools.ToRadians(45), 1, scene);",
				"    BABYLON.NodeMaterial.ParseFromSnippetAsync(\"RXBW6F#51\", scene).then((nodeMaterial) => {",
				"        // var proceduralTexture = new BABYLON.Texture(\"https://cdn.jsdelivr.net/gh/PirateJC/assets@99f103edcc84bb0dc1cd8c655acaf7b51b9d6a8e/selectionCircle.png\", scene);",
				"        //console.log(\"node material\",nodeMaterial);",
				"        var proceduralTexture = nodeMaterial.createProceduralTexture(256, scene);",
				"        light.position.x = 0;",
				"        light.position.y = 17.8;",
				"        light.position.z = 30;",
				"        light.intensity = 0;",
				"        light.setDirectionToTarget(new BABYLON.Vector3(0,0,30));",
				"        // selectionLight.intensity = 10;",
				"        light.projectionTexture = proceduralTexture;",
				"        ",
				"        for (var mesh_name of causticEffectMeshList){",
				"            let mesh = scene.getMeshByName(mesh_name);",
				"            if (mesh){",
				"                let subMesh = mesh.clone(\"clone_\"+mesh_name);",
				"                var groundMaterial = new BABYLON.StandardMaterial(\"clone_\"+mesh_name, scene);",
				"                groundMaterial.diffuseTexture = mesh.material.albedoTexture;",
				"                groundMaterial.bumpTexture =  mesh.material.bumpTexture;",
				"                subMesh.material = groundMaterial;",
				"\t\t\t\t//console.log( mesh.material.specularColor )",
				"                subMesh.material.specularColor = new BABYLON.Color3(0.4,0.4,1);",
				"\t\t\t\tsubMesh.material.emissiveColor = mesh.material.emissiveColor;",
				"\t\t\t\t",
				"\t\t\t\tif (mesh_name == emissiveMesh) setEmissionMaterial(subMesh);",
				"                light.includedOnlyMeshes.push(subMesh);",
				"                subMesh.isVisible = false;",
				"",
				"                subMeshList.push(subMesh);",
				"                mainMeshList.push(mesh);",
				"            }",
				"        }",
				"\t\t//let plane = scene.getMeshByName(\"clone_Floor.002\");",
				"\t\t//plane.material.diffuseTexture = new BABYLON.Texture(\"./assets/SeaFloor_BCAO_512_02.png\",scene);",
				"    });",
				"    return light;",
				"}",
				"",
				"function controlFog(state){",
				"    if (state){",
				"        scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;",
				"        scene.fogStart = 5;",
				"        scene.fogEnd = 19.5;",
				"        scene.fogColor = new BABYLON.Color3(0.071, 0.184, 0.545);",
				"        scene.ambientColor = scene.fogColor;",
				"        scene.fogDensity = 0.1;",
				"        scene.clearColor = scene.fogColor;",
				"    }else{",
				"        //scene.fogMode = BABYLON.Scene.FOGMODE_NONE;",
				"        //scene.clearColor = initBackgroundColor;",
				"        //scene.ambientColor = initBackgroundColor;",
				"    }",
				"}",
				"",
				"",
				"//control roof and wall (true : open, false : close)",
				"// function roomControl(list, state){",
				"//     for(var mesh_name of list){",
				"//         let mesh = scene.getMeshByName(mesh_name);",
				"//         if (mesh){",
				"//             mesh.setEnabled(state);",
				"//         }else{",
				"// \t\t\tlet node = scene.getTransformNodeByName(mesh_name);",
				"// \t\t\tif (node) {",
				"// \t\t\t\tnode.setEnabled(state);",
				"// \t\t\t}else{",
				"",
				"// \t\t\tconsole.log('mesh not found', mesh_name);",
				"// \t\t\t}",
				"// \t\t}",
				"//     }",
				"    ",
				"// }",
				"",
				"function controlWaterPlane(state){",
				"    causticLight.intensity = state ? 0.8 : 0;",
				"    for (let i=0; i<subMeshList.length;i++){",
				"        subMeshList[i].isVisible = state;",
				"        mainMeshList[i].isVisible= !state;",
				"    }",
				"}",
				"",
				"//for temprary use",
				"function setEmissionMaterial(subMesh){",
				"\tconst emissionColor = new BABYLON.Color3(0.3,0.3,0.3);",
				"\tsubMesh.material.emissiveColor = emissionColor;",
				"\t",
				"}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "VolumeLightParticle",
			"source": [
				"",
				"//https://playground.babylonjs.com/#5FJI1S",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"// const particleTexture = new BABYLON.Texture(\"./assets/volumetricLight.png\");",
				"let volumetricEmitter = null;",
				"let particleSystem = null;",
				"",
				"",
				"function start(){",
				" particleSystem = createVolumeLightParticleSystem();",
				"//  particleSystem.start();",
				" //console.log(\"start\");",
				"}",
				"",
				"function end(){",
				"particleSystem.stop();",
				"particleSystem.dispose();",
				"}",
				"",
				"function update( progress ){",
				"    ",
				"}",
				"function createVolumeLightParticleSystem(){",
				"    // setup the \"god rays\"",
				"    // particle system variables",
				"    if (!volumetricEmitter) volumetricEmitter = new BABYLON.AbstractMesh(\"volumetricEmitter\", scene);",
				"    volumetricEmitter.position = new BABYLON.Vector3(0,1.5,30);",
				"    // set up animation sheet",
				"    let setupAnimationSheet = function (system, texture, width, height, numSpritesWidth, numSpritesHeight, animationSpeed, isRandom) {",
				"        // assign animation parameters",
				"        system.isAnimationSheetEnabled = true;",
				"        system.particleTexture = new BABYLON.Texture(texture, scene, false, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);",
				"        system.particleTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;",
				"        system.particleTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;",
				"        system.spriteCellWidth = width / numSpritesWidth;",
				"        system.spriteCellHeight = height / numSpritesHeight;",
				"        let numberCells = numSpritesWidth * numSpritesHeight;",
				"        system.startSpriteCellID = 0;",
				"        system.endSpriteCellID = numberCells - 1;",
				"        system.spriteCellChangeSpeed = animationSpeed;",
				"        system.spriteRandomStartCell = isRandom;",
				"        system.updateSpeed = 1 / 30;",
				"    };",
				"",
				"    // particle system",
				"    let volumetricSystem = new BABYLON.ParticleSystem(\"volumetricSystem\", 100, scene, null, true);",
				"    setupAnimationSheet(volumetricSystem, \"https://models.babylonjs.com/Demos/UnderWaterScene/godRays/volumetricLight.png\", 1024, 1024, 4, 1, 0, true);",
				"    volumetricSystem.emitter = volumetricEmitter.position;",
				"    let boxEmitter = volumetricSystem.createBoxEmitter(new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(-5, 5, -3), new BABYLON.Vector3(5, 5, 3));",
				"    boxEmitter.radiusRange = 0;",
				"    volumetricSystem.minInitialRotation = 0;",
				"    volumetricSystem.maxInitialRotation = 0;",
				"    volumetricSystem.minScaleX = 6;",
				"    volumetricSystem.maxScaleX = 10;",
				"    volumetricSystem.minScaleY = 30;",
				"    volumetricSystem.maxScaleY = 50;",
				"    volumetricSystem.minLifeTime = 6;",
				"    volumetricSystem.maxLifeTime = 9;",
				"    volumetricSystem.emitRate = 15;",
				"    volumetricSystem.minEmitPower = 0.05;",
				"    volumetricSystem.maxEmitPower = 0.1;",
				"    volumetricSystem.minSize = 0.1;",
				"    volumetricSystem.maxSize = 0.2;",
				"    volumetricSystem.addColorGradient(0, new BABYLON.Color4(0, 0, 0, 0));",
				"    volumetricSystem.addColorGradient(0.5, new BABYLON.Color4(0.25, 0.25, 0.3, 0.2));",
				"    volumetricSystem.addColorGradient(1.0, new BABYLON.Color4(0, 0, 0, 0));",
				"    volumetricSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;",
				"    volumetricSystem.start();",
				"    return volumetricSystem;",
				"}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"const particleSystem = new BABYLON.ParticleSystem(\"new particle\", 10, scene);",
				"particleSystem.start();",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "grass_control",
			"source": [
				"",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"const min_visible_progress = 0.06;",
				"const max_visible_progress = 0.15;",
				"const range_progress = max_visible_progress - min_visible_progress;",
				"",
				"",
				"let Lawn_primitive0 = scene.getMeshByName(\"Lawn_primitive0\");",
				"Lawn_primitive0.material.dissolve.isEnabled = true;",
				"Lawn_primitive0.applyFog = false;",
				"let Lawn_primitive1 = scene.getMeshByName(\"Lawn_primitive1\");",
				"",
				"",
				"Lawn_primitive1.material.dissolve.isEnabled = true;",
				"Lawn_primitive1.applyFog = false;",
				"const Ivy_Wall_R_primitive1 = scene.getMeshByName(\"Ivy Wall_R_primitive1\");",
				"const Ivy_Wall_R_primitive0 = scene.getMeshByName(\"Ivy Wall_R_primitive0\");",
				"",
				"Lawn_primitive0.visibility = 0;",
				"Lawn_primitive1.visibility = 0;",
				"Ivy_Wall_R_primitive0.visibility = 0;",
				"Ivy_Wall_R_primitive1.visibility = 0;",
				"",
				"function start(){",
				"    //grass = scene.getMeshByName(\"Grass\");",
				"    // if (grass){",
				"    //     grass.visibility = 1.0;",
				"    // }",
				"\t//app.playAnimation(parameters.type.value, parameters.name.value)",
				"}",
				"",
				"function end(){",
				"    //let grass = scene.getMeshByName(\"Grass\");",
				"//     if (grass){",
				"//         grass.visibility = 0.0;",
				"//     }",
				"}",
				"function clamp(input, min, max) {",
				"  return input < min ? min : input > max ? max : input;",
				"}",
				"function map(current, in_min, in_max, out_min, out_max) {",
				"  const mapped = ((current - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min;",
				"  return clamp(mapped, out_min, out_max);",
				"}",
				"function update( progress ){",
				"\tlet _progress = progress - min_visible_progress;",
				"\t\t\t",
				"\t\tlet outerRadius = map(progress, 0, 0.06, 0.0, 9.0);",
				"\t\tlet innerRadius = map(progress, 0, 0.06, 0.0, 6.0);",
				"\t\t",
				"\t\t//grass.material.setFloat(\"outerRadius\", outerRadius);",
				"\t\t//grass.material.setFloat(\"innerRadius\", innerRadius);",
				"",
				"\t\t//grass.visibility = map(progress, 0, 0.06, 0.0, 1.0);",
				"\t\tLawn_primitive0.visibility = map(progress, 0, 0.06, 0.0, 1.0);",
				"\t\tLawn_primitive1.visibility = map(progress, 0, 0.06, 0.0, 1.0);",
				"\t\tIvy_Wall_R_primitive0.visibility = map(progress, 0, 0.06, 0.0, 1.0);",
				"\t\tIvy_Wall_R_primitive1.visibility = map(progress, 0, 0.06, 0.0, 1.0);",
				"\t",
				"}"
			]
		},
		{
			"name": "SeaDust",
			"source": [
				"",
				"",
				"var parameters = {",
				"};",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"const particleTexture = new BABYLON.Texture(\"./assets/flare.png\", scene);",
				"const dustEffect = createDustParticleEffect();",
				"//dust_particle_system.stop();",
				"",
				"function start(){",
				"\tdustEffect.start();",
				"}",
				"",
				"function end(){",
				"    dustEffect.stop();",
				"\t//console.log('end dust');",
				"}",
				"",
				"function update( progress ){}",
				"",
				"function createDustParticleEffect(){",
				"    let particleSystem = new BABYLON.ParticleSystem(\"SeaDust\", 500, scene)",
				"    //console.log(\"particle system \",particleSystem)",
				"    particleSystem.particleTexture = particleTexture;",
				"    ",
				"    ",
				"    //setting emission",
				"    // let emitterBox = new BABYLON.CreateBox(\"Sea Dust Emitter\", {size:10}, scene);",
				"    // emitterBox.position = new BABYLON.Vector3(0,2.5,15);",
				"    // emitterBox.rotation = new BABYLON.Vector3(Math.PI/2, Math.PI, 0)",
				"    // emitterBox.visibility = 0;",
				"    particleSystem.emitter = camera;",
				"    particleSystem.emitRate = 100.0;",
				"    particleSystem.minEmitBox = new BABYLON.Vector3(-2,0,15);",
				"    particleSystem.maxEmitBox = new BABYLON.Vector3(2,3,30);",
				"",
				"    //setting life time",
				"    particleSystem.minLifeTime = 1.0;",
				"    particleSystem.maxLifeTime = 5.0;",
				"",
				"    //setting color",
				"    // console.log(\"color gradient function\",particleSystem.addColorGradiant);",
				"    particleSystem.addColorGradient(0, new BABYLON.Color4(0,0,0,0), new BABYLON.Color4(0,0,0,0));",
				"    particleSystem.addColorGradient(0.5, new BABYLON.Color4(1,1,1,0.6), new BABYLON.Color4(1,1,1,0.6));",
				"    particleSystem.addColorGradient(1.0, new BABYLON.Color4(0,0,0,1), new BABYLON.Color4(0,0,0,1));",
				"    ",
				"    //emitssion power",
				"    particleSystem.minEmitPower = 15;",
				"    particleSystem.maxEmitPower = 20;",
				"",
				"    //particle random scale",
				"    particleSystem.minSize = 0.05;",
				"    particleSystem.maxSize = 0.15;",
				"    particleSystem.direction1 = new BABYLON.Vector3(-1,0.5,-1);",
				"    particleSystem.direction2 = new BABYLON.Vector3(1,-0.5,-1);",
				"",
				"    particleSystem.stop();",
				"    return particleSystem;",
				"}"
			]
		},
		{
			"name": "BoidsEffect",
			"source": [
				"",
				"",
				"var parameters = {",
				"};",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"let total = (app.devicePerformance.tier < 3 || app.devicePerformance.isMobile) ? 15: 50;",
				"const models = loadModels(total);",
				"var boidsManager = null;",
				"",
				"//initBoids();",
				"function start(){",
				"    initBoids();",
				"}",
				"",
				"function end(){",
				"    endBoids();",
				"}",
				"",
				"function update( progress ){",
				"",
				"}",
				"",
				"function initBoidsManager(total){",
				"    const boidsCenter = new BABYLON.Vector3(-3,1.5,35);",
				"    boidsManager = scene.createBoidsManager(total, boidsCenter, 0.5, 3);",
				"    for(let i=0; i<total; i++){",
				"        models[i].boid = boidsManager.boids[i];",
				"        models[i].boid.velocity = models[i].boid.velocity.normalize();",
				"        models[i].force = new BABYLON.Vector3(0, 0, 0);",
				"    }",
				"    //boidsManager.showDebug(scene);",
				"    // boidsManager.gui(scene);",
				"    ",
				"}",
				"",
				"function loadModels(total){",
				"",
				"    const _models = [];",
				"\tconst fishParent = scene.getTransformNodeByName(\"Empty.002\");",
				"    const fishModel = scene.getMeshByName(\"Scombrus_Anim\");",
				"    fishModel.setEnabled(true);",
				"    const fishMaterial = new BABYLON.StandardMaterial('fish',scene);",
				"    fishMaterial.diffuseTexture = fishModel.material.albedoTexture;",
				"    fishMaterial.bumpTexture =  fishModel.material.bumpTexture;",
				"    //create box mesh for test",
				"    for(let i=0; i<total; i++){",
				"\t\tconst cloneNode = fishParent.clone(\"parent_node\"); ",
				"\t\tcloneNode.parent = null",
				"        const fish = fishModel.clone(\"clone_\" + i.toString() + \"_fish\");",
				"        // const fish = BABYLON.MeshBuilder.CreateBox(\"box\"+i,{",
				"        //     width: 0.1,",
				"        //     height: 0.2,",
				"        //     depth: 0.3,",
				"        // }, scene)",
				"        // fish.name = \"clone_\" + i.toString() + \"_fish\";",
				"\t\tfish.parent = cloneNode;",
				"        fish.material = fishMaterial;",
				"\t\t",
				"\t\tcloneNode.scalingDeterminant = 0.3;",
				"        _models.push(cloneNode);",
				"    }",
				"    //fishModel.setEnabled(false);",
				"    return _models;",
				"}",
				"",
				"function updateBoids(){",
				"    const timeDiff = engine.getDeltaTime() / 1000.0;",
				"    boidsManager.update(timeDiff);",
				"    models.forEach((m)=>{",
				"        m.position.copyFrom(m.boid.position);",
				"        m.setDirection(m.boid.orientation);",
				"    })",
				"}",
				"function initBoids(){",
				"    //init position",
				"    initBoidsManager(total);",
				"    ",
				"    // console.log('init boids', boidsManager);",
				"",
				"    //set to visible ",
				"    for (var model of models){",
				"        model.setEnabled(true);",
				"    }",
				"",
				"    //add update callback",
				"    scene.onBeforeRenderObservable.add(updateBoids)",
				"}",
				"",
				"function endBoids(){",
				"    // console.log('end boids', boidsManager);",
				"    //set to invisible",
				"    for (var model of models){",
				"        model.setEnabled(false);",
				"    }",
				"    boidsManager = null;",
				"    //remove update callback",
				"    let removeResult = scene.onBeforeRenderObservable.removeCallback(updateBoids)",
				"    // console.log('remove result', removeResult);",
				"}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "MoveGodlightEffect",
			"source": [
				"var parameters = {",
				"};",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"let isInit = false;",
				"let godlightMesh = null;",
				"",
				"function start(){",
				"\tif (!isInit){",
				"\t\tgodlightMesh = scene.getMeshByName(\"VolumetricLightScatteringMesh\");",
				"\t\tgodlightMesh.position.x = - 100;",
				"\t\tisInit = true;",
				"\t}",
				"}",
				"",
				"function end(){",
				"\tif (isInit){",
				"\t\tgodlightMesh.position.x = 100;",
				"\t\tisInit = false;",
				"\t}",
				"}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "VolumetricCloud",
			"source": [
				"",
				"var parameters = {",
				"};",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"var particleSystem;",
				"var useGPUVersion = false;",
				"var fountain = BABYLON.Mesh.CreateBox(\"foutain\", .01, scene);",
				"    fountain.visibility = 0;",
				"    fountain.position = new BABYLON.Vector3(0,0, 40);",
				"",
				"const fogTexture = new BABYLON.Texture(\"https://raw.githubusercontent.com/aWeirdo/Babylon.js/master/smoke_15.png\", scene);",
				"",
				"",
				"var createNewSystem = function () {",
				"    if (particleSystem) {",
				"        particleSystem.dispose();",
				"    }",
				"",
				"    if (useGPUVersion && BABYLON.GPUParticleSystem.IsSupported) {",
				"        particleSystem = new BABYLON.GPUParticleSystem(\"particles\", { capacity: 50000 }, scene);",
				"        particleSystem.activeParticleCount = 15000;",
				"        particleSystem.manualEmitCount = particleSystem.activeParticleCount;",
				"        particleSystem.minEmitBox = new BABYLON.Vector3(-50, 2, 30); // Starting all from",
				"        particleSystem.maxEmitBox = new BABYLON.Vector3(50, 2, 70); // To..",
				"",
				"    } else {",
				"        particleSystem = new BABYLON.ParticleSystem(\"particles\", 5000, scene);",
				"        //particleSystem.manualEmitCount = particleSystem.getCapacity();",
				"        particleSystem.minEmitBox = new BABYLON.Vector3(-3, 0, -5); // Starting all from",
				"        particleSystem.maxEmitBox = new BABYLON.Vector3(3, 0.8, 30); // To...",
				"    }",
				"",
				"",
				"    particleSystem.particleTexture = fogTexture.clone();",
				"    particleSystem.emitter = fountain;",
				"\tparticleSystem.preWarmCycles = 100;",
				"\tparticleSystem.preWarmStepOffset = 5;",
				"    particleSystem.color1 = new BABYLON.Color4(1, 1, 1, 0.1);",
				"    particleSystem.color2 = new BABYLON.Color4(1, 1, 1, 0.35);",
				"    particleSystem.colorDead = new BABYLON.Color4(0.9, 0.9, 0.9, 0);",
				"    particleSystem.minSize = 1.0;",
				"    particleSystem.maxSize = 2.5;",
				"    particleSystem.minLifeTime = 5;",
				"    particleSystem.emitRate = 2500;",
				"    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;",
				"    particleSystem.gravity = new BABYLON.Vector3(0, 0, 0);",
				"    particleSystem.direction1 = new BABYLON.Vector3(0, 0, 0);",
				"    particleSystem.direction2 = new BABYLON.Vector3(0, 0.3, 0);",
				"    particleSystem.minAngularSpeed = -2;",
				"    particleSystem.maxAngularSpeed = 2;",
				"    particleSystem.minEmitPower = .5;",
				"    particleSystem.maxEmitPower = 1;",
				"    particleSystem.updateSpeed = 0.005;",
				"",
				"    particleSystem.start();",
				"}",
				"",
				"",
				"    createNewSystem();",
				"\t if (particleSystem) {",
				"        particleSystem.dispose();",
				"    }",
				"function start(){",
				"    createNewSystem();",
				"}",
				"",
				"function end(){",
				"    if (particleSystem) {",
				"        particleSystem.dispose();",
				"    }",
				"}",
				"",
				"function update( progress ){",
				"}"
			]
		},
		{
			"name": "SquiralAnimation",
			"source": [
				"var parameters = {",
				"\ttype: new FRAME.Parameters.String( 'type', \"clip\" ),",
				"\tname: new FRAME.Parameters.String( 'name', \"Squirrel_AllAnim\" ),",
				"};",
				"",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"",
				"function start(){",
				"//console.log('start');",
				"\tapp.playAnimation(parameters.type.value, parameters.name.value)",
				"}",
				"",
				"function end(){",
				"//console.log('end');",
				"}",
				"",
				"function update( progress ){",
				"//console.log('update', progress);",
				"}"
			]
		},
		{
			"name": "SetPlayerPos",
			"source": [
				"",
				"var parameters = {",
				"};",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"function start(){",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){",
				"}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "RoomControl",
			"source": [
				"",
				"// this effect is used to control different region object control",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"const onlyEnterOpeClose = [\"TheaterScreen_02_L\", \"TheaterScreen_02_R\", \"Scombrus_Anim\", \"Empty.002\"]",
				"const closeWhenEnter = [\"Ceiling.001_repair\", \"BlockPlane\"];",
				"const openWhenEnter = [];",
				"roomControl(openWhenEnter, false);",
				"roomControl(onlyEnterOpeClose, false);",
				"let fogStatus = false;",
				"prewarmFog()",
				"",
				"function prewarmFog(){",
				" \tscene.fogMode = BABYLON.Scene.FOGMODE_EXP2;",
				" \t// scene.fogStart = 99;",
				"\t// scene.fogEnd = 99;",
				"    scene.fogColor = new BABYLON.Color3(219/255, 212/255, 189/255);",
				"\tscene.ambientColor = scene.fogColor;",
				"    scene.clearColor = scene.fogColor;",
				"\tscene.fogDensity = 0.035",
				"\tfogStatus = true;",
				"\tconsole.log('prewarm fog', scene.fogColor);",
				"}",
				"",
				"function start(){",
				"    roomControl(openWhenEnter, true);",
				"    roomControl(closeWhenEnter, false);",
				"\tprewarmFog();",
				"\t",
				"\tapp.playAnimation(\"clip\", \"Squirrel_Idle\", true);",
				"\tapp.playAnimation(\"clip\", \"Bird_Idle\", true);",
				"\t",
				"}",
				"",
				"function end(){",
				"    roomControl(openWhenEnter, false);",
				"    roomControl(closeWhenEnter, true);",
				"}",
				"",
				"function update( progress ){",
				"    ",
				"}",
				"",
				"//control roof and wall (true : open, false : close)",
				"function roomControl(list, state){",
				"    for(var mesh_name of list){",
				"        let mesh = scene.getMeshByName(mesh_name);",
				"        if (mesh){",
				"            mesh.setEnabled(state);",
				"        }else{",
				"\t\t\tlet node = scene.getTransformNodeByName(mesh_name);",
				"\t\t\tif (node) {",
				"\t\t\t\tnode.setEnabled(state);",
				"\t\t\t}else{",
				"",
				"\t\t\t//console.log('mesh not found', mesh_name);",
				"\t\t\t}",
				"\t\t}",
				"    }",
				"    ",
				"}"
			]
		},
		{
			"name": "RoomControl",
			"source": [
				"",
				"// this effect is used to control different region object control",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"const onlyEnterOpen = [\"TheaterScreen_02_L\", \"TheaterScreen_02_R\"]",
				"const onlyEnterClose = [ \"Seabaed  Rock _All\"];",
				"const closeWhenEnter = [\"VolumetricLightScatteringMesh\", \"Ceiling_Cube_Lp.001\",\"Lv2_Pillar\"];",
				"const openWhenEnter = [ \"Paint_WH\",\"Anchor\",\"Seabaed  Rock _All\",\"Sand\", \"clone_Seabaed  Rock _All\",\"clone_Sand\", \"Easel_Control\", \"clone_Railing_SecPillar\", \"clone_Display Stand_Lp\"];",
				"",
				"//execute when enter scene",
				"roomControl(openWhenEnter, false);",
				"roomControl(onlyEnterClose, false);",
				"app.playAnimation(\"clip\",\"Nobel_TPAction_All\", true);",
				"",
				"function getAnimation(animationName){",
				"\tfor(var i=0;i<scene.animationGroups.length;i++){",
				"\t\tlet animationGroup = scene.animationGroups[i];",
				"\t\t//console.log(\"animationGroup\",animationGroup);",
				"\t\tif (animationGroup.name == animationName){",
				"\t\t\treturn animationGroup;",
				"\t\t}",
				"",
				"\t}",
				"\treturn null;",
				"}",
				"function playAnimation(animationName){",
				"\tlet animation = getAnimation(animationName);",
				"\tif (animation){",
				"\t\tanimation.play();",
				"\t",
				"\t}",
				"}",
				"function resetAnimation(animationName){",
				"\tlet animation = getAnimation(animationName);",
				"\tif (animation){",
				"\t\tanimation.goToFrame(0);",
				"\t\tanimation.pause();",
				"\t\tconsole.log('pause animation', animationName);",
				"\t}",
				"}",
				"",
				"function start(){",
				" \troomControl(onlyEnterOpen, true);",
				"    roomControl(openWhenEnter, true);",
				"    roomControl(closeWhenEnter, false);",
				"}",
				"",
				"function end(){",
				"    roomControl(openWhenEnter, false);",
				"    roomControl(closeWhenEnter, true);",
				"\tresetAnimation(\"Whale_AllAnim\");",
				"}",
				"",
				"function update( progress ){",
				"    ",
				"}",
				"",
				"//control roof and wall (true : open, false : close)",
				"function roomControl(list, state){",
				"    for(var mesh_name of list){",
				"        let mesh = scene.getMeshByName(mesh_name);",
				"        if (mesh){",
				"            mesh.setEnabled(state);",
				"        }else{",
				"\t\t\tlet node = scene.getTransformNodeByName(mesh_name);",
				"\t\t\tif (node) {",
				"\t\t\t\tnode.setEnabled(state);",
				"\t\t\t}else{",
				"",
				"\t\t\t//console.log('mesh not found', mesh_name);",
				"\t\t\t}",
				"\t\t}",
				"    }",
				"    ",
				"}"
			]
		},
		{
			"name": "PlayAnimation",
			"source": [
				"var parameters = {",
				"\ttype: new FRAME.Parameters.String( 'type', \"clip\" ),",
				"\tname: new FRAME.Parameters.String( 'name', \"Whale_AllAnim\" ),",
				"};",
				"",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"function start(){",
				"\tapp.playAnimation(parameters.type.value, parameters.name.value)",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "PlayAnimation",
			"source": [
				"var parameters = {",
				"\ttype: new FRAME.Parameters.String( 'type', \"group\" ),",
				"\tname: new FRAME.Parameters.String( 'name', \"NTT\" ),",
				"};",
				"",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"function start(){",
				"\tapp.playAnimation(parameters.type.value, parameters.name.value)",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\ttype: new FRAME.Parameters.String( 'type', \"group\" ),",
				"\tname: new FRAME.Parameters.String( 'name', \"Nobel\" ),",
				"};",
				"",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"app.playAnimation(parameters.type.value, parameters.name.value, true)",
				"",
				"function start(){",
				"\t",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "RoomControl",
			"source": [
				"",
				"// this effect is used to control different region object control",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"const closeWhenEnter = [];",
				"const openWhenEnter = [\"Tai-Chi Statue_Anim\"];",
				"roomControl(openWhenEnter, false);",
				"",
				"function start(){",
				"    roomControl(openWhenEnter, true);",
				"    roomControl(closeWhenEnter, false);",
				"}",
				"",
				"function end(){",
				"    roomControl(openWhenEnter, false);",
				"    roomControl(closeWhenEnter, true);",
				"}",
				"",
				"function update( progress ){",
				"    ",
				"}",
				"",
				"//control roof and wall (true : open, false : close)",
				"function roomControl(list, state){",
				"    for(var mesh_name of list){",
				"        let mesh = scene.getMeshByName(mesh_name);",
				"        if (mesh){",
				"            mesh.setEnabled(state);",
				"        }else{",
				"\t\t\tlet node = scene.getTransformNodeByName(mesh_name);",
				"\t\t\tif (node) {",
				"\t\t\t\tnode.setEnabled(state);",
				"\t\t\t}else{",
				"",
				"\t\t\t//console.log('mesh not found', mesh_name);",
				"\t\t\t}",
				"\t\t}",
				"    }",
				"    ",
				"}"
			]
		},
		{
			"name": "PlayAnimation",
			"source": [
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"",
				"",
				"function getAnimation(animationName){",
				"\tfor(var i=0;i<scene.animationGroups.length;i++){",
				"\t\tlet animationGroup = scene.animationGroups[i];",
				"\t\t//console.log(\"animationGroup\",animationGroup);",
				"\t\tif (animationGroup.name == animationName){",
				"\t\t\treturn animationGroup;",
				"\t\t}",
				"",
				"\t}",
				"\treturn null;",
				"}",
				"function playAnimation(animationName, isloop){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.play(isloop);",
				"\t",
				"\t}",
				"\t//console.log(\"theator\",theatorAnimation);",
				"}",
				"function pauseAnimation(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.pause();",
				"\t",
				"\t}",
				"}",
				"function resetAnimation(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.goToFrame(0);",
				"\t\ttheatorAnimation.pause();",
				"\t}",
				"}",
				"",
				"function start(){",
				"\tlet animation_1 = \"TheaterScreen_L\";",
				"\tplayAnimation(animation_1, false);",
				"\t",
				"\tlet animation_2 = \"TheaterScreen_R\";",
				"\tplayAnimation(animation_2, false);",
				"\t",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "TheatirAnimationReset",
			"source": [
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"",
				"",
				"function getAnimation(animationName){",
				"\tfor(var i=0;i<scene.animationGroups.length;i++){",
				"\t\tlet animationGroup = scene.animationGroups[i];",
				"\t\t//console.log(\"animationGroup\",animationGroup);",
				"\t\tif (animationGroup.name == animationName){",
				"\t\t\treturn animationGroup;",
				"\t\t}",
				"",
				"\t}",
				"\treturn null;",
				"}",
				"function playAnimation(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.play();",
				"\t",
				"\t}",
				"\t//console.log(\"theator\",theatorAnimation);",
				"}",
				"function pauseAnimation(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.pause();",
				"\t",
				"\t}",
				"}",
				"function resetAnimation(animationName,frame=0){",
				"",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\tif (frame == 'end') frame = theatorAnimation._to;",
				"\t\ttheatorAnimation.play();",
				"\t\ttheatorAnimation.goToFrame(frame);",
				"\t\ttheatorAnimation.pause();",
				"\t\tconsole.log('animation time',theatorAnimation,frame)",
				"\t}else{",
				"\t\tconsole.error('animation not found', animationName);",
				"\t}",
				"}",
				"",
				"function start(prevTime, time){",
				"\t//if (prevTime > time)return",
				"\tlet animation_1 = \"TheaterScreen_L\";",
				"\tresetAnimation(animation_1);",
				"\t",
				"\tlet animation_2 = \"TheaterScreen_R\";",
				"\tresetAnimation(animation_2);",
				"\t",
				"\t//console.log('theator enter');",
				"}",
				"",
				"function end(prevTime, time){",
				"\tif (prevTime > time) {",
				"\t\tlet animation_1 = \"TheaterScreen_L\";",
				"\t\tresetAnimation(animation_1, 'end');",
				"\t",
				"\t\tlet animation_2 = \"TheaterScreen_R\";",
				"\t\tresetAnimation(animation_2, 'end');",
				"\t\tconsole.log('backward end animation',prevTime, time);",
				"\t}else{",
				"\t\tlet animation_1 = \"TheaterScreen_L\";",
				"\t\tplayAnimation(animation_1);",
				"\t",
				"\t\tlet animation_2 = \"TheaterScreen_R\";",
				"\t\tplayAnimation(animation_2);",
				"\t\tconsole.log('forward end animation',prevTime, time);",
				"\t}",
				"\t",
				"\t",
				"\t//console.log('theator end');",
				"}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "TaichiAnimationControl",
			"source": [
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"",
				"",
				"function getAnimation(animationName){",
				"\tfor(var i=0;i<scene.animationGroups.length;i++){",
				"\t\tlet animationGroup = scene.animationGroups[i];",
				"\t\t//console.log(\"animationGroup\",animationGroup);",
				"\t\tif (animationGroup.name == animationName){",
				"\t\t\treturn animationGroup;",
				"\t\t}",
				"",
				"\t}",
				"\treturn null;",
				"}",
				"function playAnimation(animationName, isloop){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.play(isloop);",
				"\t",
				"\t}",
				"\t//console.log(\"theator\",theatorAnimation);",
				"}",
				"function pauseAnimation(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.pause();",
				"\t",
				"\t}",
				"}",
				"function resetAnimation(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.goToFrame(0);",
				"\t\ttheatorAnimation.pause();",
				"\t}",
				"}",
				"",
				"function goToLastFrame(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.goToFrame(theatorAnimation.to);",
				"\t\ttheatorAnimation.pause();",
				"\t}",
				"}",
				"",
				"function start(){",
				"\tlet animation_1 = \"Tai-Chi Statue_Anim\";",
				"\t//goToLastFrame(animation_1);",
				"\t",
				"\tresetAnimation(animation_1);",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "TaichiAnimationPlay",
			"source": [
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"",
				"",
				"function getAnimation(animationName){",
				"\tfor(var i=0;i<scene.animationGroups.length;i++){",
				"\t\tlet animationGroup = scene.animationGroups[i];",
				"\t\t//console.log(\"animationGroup\",animationGroup);",
				"\t\tif (animationGroup.name == animationName){",
				"\t\t\treturn animationGroup;",
				"\t\t}",
				"",
				"\t}",
				"\treturn null;",
				"}",
				"function playAnimation(animationName, isloop){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.play(isloop);",
				"\t",
				"\t}",
				"\t//console.log(\"theator\",theatorAnimation);",
				"}",
				"function pauseAnimation(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.pause();",
				"\t",
				"\t}",
				"}",
				"function resetAnimation(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.goToFrame(0);",
				"\t\ttheatorAnimation.pause();",
				"\t}",
				"}",
				"",
				"function goToLastFrame(animationName){",
				"\tlet theatorAnimation = getAnimation(animationName);",
				"\tif (theatorAnimation){",
				"\t\ttheatorAnimation.goToFrame(theatorAnimation.to);",
				"\t\ttheatorAnimation.pause();",
				"\t}",
				"}",
				"",
				"function start(){",
				"\tlet animation_1 = \"Tai-Chi Statue_Anim\";",
				"\tresetAnimation(animation_1);",
				"\t",
				"\tplayAnimation(animation_1, false);",
				"\t",
				"}",
				"",
				"function end(){",
				"let animation_1 = \"Tai-Chi Statue_Anim\";",
				"\t//playAnimation(animation_1, false);",
				"}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "ArmillaryEffectTest",
			"source": [
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"",
				"function start(){",
				"\tscene.armillary.switchMode(scene.armillary._mode == 0 ? 1 : 0);",
				"    scene.planets.switchMode(scene.planets._mode == 0 ? 1 : 0);",
				"",
				"}",
				"",
				"function end(){",
				"\tscene.armillary.switchMode(scene.armillary._mode == 0 ? 1 : 0);",
				"    scene.planets.switchMode(scene.planets._mode == 0 ? 1 : 0);",
				"}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "CameraRotationTest",
			"source": [
				"",
				"// this effect is used to control different region object control",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){",
				"\tcamera.rotation.y += 3.14/50;",
				"\tconsole.log(camera.rotation)",
				"}"
			]
		},
		{
			"name": "Bubbles",
			"source": [
				"var parameters = {",
				"};",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"//./assets/flare.png",
				"//let texture = getTexture(\"./assets/flare.png\");",
				"let texture = new BABYLON.Texture(\"./assets/Bubbles.png\", scene);",
				"let particleSystem = initParticleSystem();",
				"texture.hasAlpha = true;",
				"let timer = null;",
				"",
				" var noiseTexture = new BABYLON.NoiseProceduralTexture(\"perlin\", 256, scene);",
				"    noiseTexture.animationSpeedFactor = 5;",
				"    noiseTexture.persistence = 2;",
				"    noiseTexture.brightness = 0.5;",
				"    noiseTexture.octaves = 2;",
				"",
				"function getTexture(textureName){",
				"\tfor(var i = 0 ; i<scene.textures.length; i++){",
				"\t\tif (scene.textures[i].name == textureName){",
				"\t\t\treturn scene.textures[i];",
				"\t\t}",
				"\t}",
				"}",
				"",
				"function initParticleSystem(){",
				"    // Create a particle system",
				"    const particleSystem = new BABYLON.ParticleSystem(\"Bubbles\", 400, scene);",
				"    particleSystem.emitter = camera;",
				"    particleSystem.emitRate = 200;",
				"",
				"    particleSystem.minEmitBox = new BABYLON.Vector3(-1,-0.5,1);",
				"    particleSystem.maxEmitBox = new BABYLON.Vector3(1,0,1.5);",
				"",
				"    particleSystem.minSize = 0.3;",
				"    particleSystem.maxSize = 0.8;",
				"",
				"    particleSystem.minEmitPower = 5;",
				"    particleSystem.maxEmitPower = 8;",
				"\t",
				"\tparticleSystem.minLifeTime = 2;",
				"    particleSystem.maxLifeTime = 2;",
				"",
				"    particleSystem.color1 = new BABYLON.Color4(35/255, 39/255, 48/255, 1);",
				"    particleSystem.color2 = new BABYLON.Color4(23/255, 58/255, 116/255, 1);",
				"    particleSystem.colorDead = new BABYLON.Color4(23/255, 58/255, 116/255, 1);",
				"",
				"   ",
				"",
				"    particleSystem.noiseTexture = noiseTexture;",
				"    particleSystem.noiseStrength = new BABYLON.Vector3(20, 0, 20);",
				"",
				"",
				"    particleSystem.renderingGroupId = 3;",
				"    particleSystem.particleTexture = texture;;",
				"    particleSystem.isLocal = true;",
				"",
				"    return particleSystem;",
				"}",
				"",
				"function play(){",
				"    ",
				"\tif (timer) {",
				"\t\t",
				"\t\tparticleSystem.stop();",
				"\t\ttimer = null;",
				"\t}",
				"    particleSystem.start();",
				"    timer = setTimeout(()=>{",
				"        particleSystem.stop();",
				"        //console.log('stop');",
				"\t\ttimer = null;",
				"    }, 300);",
				"}",
				"",
				"",
				"function start(prev, time){",
				"\t//console.log(\"bubble\",prev, time, this);",
				"\tif (prev - time > 0 )return;",
				"    play();",
				"}",
				"",
				"function end(prev, time){",
				"\tif (prev < time )return;",
				"\tplay();",
				"}",
				"",
				"function update( progress ){",
				"}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "VolumeLight2",
			"source": [
				"",
				"//https://playground.babylonjs.com/#5FJI1S",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"// const particleTexture = new BABYLON.Texture(\"./assets/volumetricLight.png\");",
				"let volumetricEmitter = null;",
				"let particleSystem = null;",
				"",
				"",
				"function start(){",
				" particleSystem = createVolumeLightParticleSystem();",
				"//  particleSystem.start();",
				" //console.log(\"start\");",
				"}",
				"",
				"function end(){",
				"particleSystem.stop();",
				"particleSystem.dispose();",
				"}",
				"",
				"function update( progress ){",
				"    ",
				"}",
				"function createVolumeLightParticleSystem(){",
				"    // setup the \"god rays\"",
				"    // particle system variables",
				"    if (!volumetricEmitter) volumetricEmitter = new BABYLON.AbstractMesh(\"volumetricEmitter2\", scene);",
				"    volumetricEmitter.position = new BABYLON.Vector3(0,1.5,48);",
				"    // set up animation sheet",
				"    let setupAnimationSheet = function (system, texture, width, height, numSpritesWidth, numSpritesHeight, animationSpeed, isRandom) {",
				"        // assign animation parameters",
				"        system.isAnimationSheetEnabled = true;",
				"        system.particleTexture = new BABYLON.Texture(texture, scene, false, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);",
				"        system.particleTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;",
				"        system.particleTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;",
				"        system.spriteCellWidth = width / numSpritesWidth;",
				"        system.spriteCellHeight = height / numSpritesHeight;",
				"        let numberCells = numSpritesWidth * numSpritesHeight;",
				"        system.startSpriteCellID = 0;",
				"        system.endSpriteCellID = numberCells - 1;",
				"        system.spriteCellChangeSpeed = animationSpeed;",
				"        system.spriteRandomStartCell = isRandom;",
				"        system.updateSpeed = 1 / 50;",
				"    };",
				"",
				"    // particle system",
				"    let volumetricSystem = new BABYLON.ParticleSystem(\"volumetricSystem\", 100, scene, null, true);",
				"    setupAnimationSheet(volumetricSystem, \"https://models.babylonjs.com/Demos/UnderWaterScene/godRays/volumetricLight.png\", 1024, 1024, 4, 1, 0, true);",
				"    volumetricSystem.emitter = volumetricEmitter.position;",
				"    let boxEmitter = volumetricSystem.createBoxEmitter(new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(-0.5, 5, -0.1), new BABYLON.Vector3(0.5, 5, 0.1));",
				"    boxEmitter.radiusRange = 0;",
				"    volumetricSystem.minInitialRotation = 0;",
				"    volumetricSystem.maxInitialRotation = 0;",
				"    volumetricSystem.minScaleX = 6;",
				"    volumetricSystem.maxScaleX = 10;",
				"    volumetricSystem.minScaleY = 30;",
				"    volumetricSystem.maxScaleY = 50;",
				"    volumetricSystem.minLifeTime = 10;",
				"    volumetricSystem.emitRate = 15;",
				"    volumetricSystem.minEmitPower = 0.05;",
				"    volumetricSystem.maxEmitPower = 0.1;",
				"    volumetricSystem.minSize = 0.1;",
				"    volumetricSystem.maxSize = 0.2;",
				"    volumetricSystem.addColorGradient(0, new BABYLON.Color4(0, 0, 0, 0));",
				"    volumetricSystem.addColorGradient(0.5, new BABYLON.Color4(0.25, 0.25, 0.3, 0.2));",
				"    volumetricSystem.addColorGradient(1.0, new BABYLON.Color4(0, 0, 0, 0));",
				"    volumetricSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;",
				"    volumetricSystem.start();",
				"    return volumetricSystem;",
				"}"
			]
		},
		{
			"name": "FogEffect",
			"source": [
				"",
				"//https://playground.babylonjs.com/#5FJI1S",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"",
				"function start(){",
				"\tscene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;",
				"\tscene.fogEnd = 25;",
				"    scene.fogColor = new BABYLON.Color3(44/255, 44/255, 44/255);",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "NobelAnimation",
			"source": [
				"var parameters = {",
				"\ttype: new FRAME.Parameters.String( 'type', \"clip\" ),",
				"\tname: new FRAME.Parameters.String( 'name', \"Nobel_TPAction_All\" ),",
				"};",
				"",
				"",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"app.playAnimation(parameters.type.value, parameters.name.value, true);",
				"function start(){",
				"//console.log(\"play animation\");",
				"\t//app.playAnimation(parameters.type.value, parameters.name.value);",
				"}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "VolumeLightParticle",
			"source": [
				"",
				"//https://playground.babylonjs.com/#5FJI1S",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"// const particleTexture = new BABYLON.Texture(\"./assets/volumetricLight.png\");",
				"let volumetricEmitter = null;",
				"let particleSystem = null;",
				"",
				"",
				"function start(){",
				"if (app.devicePerformance.tier < 3 || app.devicePerformance.isMobile ){",
				" particleSystem = createVolumeLightParticleSystem();",
				"}",
				"}",
				"",
				"function end(){",
				"if (app.devicePerformance.tier < 3 || app.devicePerformance.isMobile ){",
				" ",
				"particleSystem.stop();",
				"particleSystem.dispose();",
				"}",
				"}",
				"",
				"function update( progress ){",
				"    ",
				"}",
				"function createVolumeLightParticleSystem(){",
				"    // setup the \"god rays\"",
				"    // particle system variables",
				"    if (!volumetricEmitter) volumetricEmitter = new BABYLON.TransformNode(\"VolumeLight_region1\", scene);",
				"    volumetricEmitter.position = new BABYLON.Vector3(0,3.5,10);",
				"    // set up animation sheet",
				"    let setupAnimationSheet = function (system, texture, width, height, numSpritesWidth, numSpritesHeight, animationSpeed, isRandom) {",
				"        // assign animation parameters",
				"        system.isAnimationSheetEnabled = true;",
				"        system.particleTexture = new BABYLON.Texture(texture, scene, false, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);",
				"        system.particleTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;",
				"        system.particleTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;",
				"        system.spriteCellWidth = width / numSpritesWidth;",
				"        system.spriteCellHeight = height / numSpritesHeight;",
				"        let numberCells = numSpritesWidth * numSpritesHeight;",
				"        system.startSpriteCellID = 0;",
				"        system.endSpriteCellID = numberCells - 1;",
				"        system.spriteCellChangeSpeed = animationSpeed;",
				"        system.spriteRandomStartCell = isRandom;",
				"        system.updateSpeed = 1 / 80;",
				"    };",
				"",
				"    // particle system",
				"    let volumetricSystem = new BABYLON.ParticleSystem(\"VolumeLight_region1\", 60, scene, null, true);",
				"    setupAnimationSheet(volumetricSystem, \"https://models.babylonjs.com/Demos/UnderWaterScene/godRays/volumetricLight.png\", 1024, 1024, 4, 1, 0, true);",
				"    volumetricSystem.emitter = volumetricEmitter.position;",
				"    let boxEmitter = volumetricSystem.createBoxEmitter(",
				"        new BABYLON.Vector3(0, 0, 0), ",
				"        new BABYLON.Vector3(0, 0, 0), ",
				"        new BABYLON.Vector3(2, 0, 15), ",
				"        new BABYLON.Vector3(2, 0, -5));",
				"    boxEmitter.radiusRange = 0;",
				"    volumetricSystem.minInitialRotation = 2.3;",
				"    volumetricSystem.maxInitialRotation = 2.3;",
				"    volumetricSystem.minScaleX = 6;",
				"    volumetricSystem.maxScaleX = 10;",
				"    volumetricSystem.minScaleY = 30;",
				"    volumetricSystem.maxScaleY = 50;",
				"    volumetricSystem.minLifeTime = 6;",
				"    volumetricSystem.maxLifeTime = 10;",
				"    volumetricSystem.emitRate = 5;",
				"    volumetricSystem.minEmitPower = 0.05;",
				"    volumetricSystem.maxEmitPower = 0.1;",
				"    volumetricSystem.minSize = 0.1;",
				"    volumetricSystem.maxSize = 0.2;",
				"    volumetricSystem.addColorGradient(0, new BABYLON.Color4(0, 0, 0, 0));",
				"    volumetricSystem.addColorGradient(0.5, new BABYLON.Color4(0.25, 0.25, 0.3, 0.2));",
				"    volumetricSystem.addColorGradient(1.0, new BABYLON.Color4(0, 0, 0, 0));",
				"    volumetricSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;",
				"    volumetricSystem.preWarmCycles = 300;",
				"    volumetricSystem.start();",
				"    return volumetricSystem;",
				"}"
			]
		},
		{
			"name": "ArmilaryEffectControl",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"var module = app.getCurrentScene().getModule('armillarySystem');",
				"",
				"function start(){",
				"module.setDisplay(true);",
				"}",
				"",
				"function end(prevTime, time){",
				"if (prevTime < time) return;",
				"module.setDisplay(false);",
				"}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"const app = document.babylonApp;",
				"const scene = app.getCurrentScene()._scene;",
				"const camera = scene.activeCamera;",
				"const engine = scene.getEngine();",
				"const BABYLON = app.getBABYLON();",
				"const UIManager = scene.UIManager;",
				"console.log(\"UIManager\", UIManager);",
				"/*",
				" UIManager.on(\"UIAll:onEnter\", ({name})=>{",
				"            console.log(\"[UIManager]\", name, \"has mouse enter\");",
				"        })",
				"*/",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		},
		{
			"name": "Effect",
			"source": [
				"var parameters = {",
				"\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )",
				"};",
				"",
				"function start(){}",
				"",
				"function end(){}",
				"",
				"function update( progress ){}"
			]
		}
	],
	"animations": [
		{
			"name": "PathControl and cameraControl",
			"start": 0,
			"end": 82.28125,
			"layer": 0,
			"effectId": 0,
			"enabled": true
		},
		{
			"name": "grass_control",
			"start": 0,
			"end": 40.33,
			"layer": 1,
			"effectId": 10,
			"enabled": true
		},
		{
			"name": "VolumeLight Particle (mobile)",
			"start": 0,
			"end": 40.33,
			"layer": 4,
			"effectId": 43,
			"enabled": true
		},
		{
			"name": "RoomControl_1",
			"start": 0,
			"end": 40.33,
			"layer": 5,
			"effectId": 22,
			"enabled": true
		},
		{
			"name": "Dust",
			"start": 0.5,
			"end": 40.36125,
			"layer": 2,
			"effectId": 4,
			"enabled": true
		},
		{
			"name": "StoneAnimation",
			"start": 27.1875,
			"end": 30.0625,
			"layer": 3,
			"effectId": 1,
			"enabled": true
		},
		{
			"name": "Animation",
			"start": 36.28125,
			"end": 38.28125,
			"layer": 6,
			"effectId": 46,
			"enabled": true
		},
		{
			"name": "TheatirAnimationReset",
			"start": 40.34375,
			"end": 68.81,
			"layer": 1,
			"effectId": 30,
			"enabled": true
		},
		{
			"name": "VolumeLightParticle",
			"start": 40.34375,
			"end": 68.8125,
			"layer": 2,
			"effectId": 8,
			"enabled": true
		},
		{
			"name": "Sea Dust",
			"start": 40.34375,
			"end": 68.8125,
			"layer": 3,
			"effectId": 11,
			"enabled": true
		},
		{
			"name": "Bubbles",
			"start": 40.34375,
			"end": 41.5625,
			"layer": 4,
			"effectId": 35,
			"enabled": true
		},
		{
			"name": "RoomControl_2",
			"start": 40.34375,
			"end": 68.81,
			"layer": 5,
			"effectId": 23,
			"enabled": true
		},
		{
			"name": "UnderseaEffect",
			"start": 40.375,
			"end": 68.81,
			"layer": 6,
			"effectId": 6,
			"enabled": true
		},
		{
			"name": "WhaleAnimation",
			"start": 41.65625,
			"end": 43.78125,
			"layer": 4,
			"effectId": 24,
			"enabled": true
		},
		{
			"name": "Boids",
			"start": 54.375,
			"end": 68.81,
			"layer": 4,
			"effectId": 12,
			"enabled": true
		},
		{
			"name": "FogEffect",
			"start": 68.82,
			"end": 82.28125,
			"layer": 1,
			"effectId": 41,
			"enabled": true
		},
		{
			"name": "VolumeLight2",
			"start": 68.82,
			"end": 82.28125,
			"layer": 2,
			"effectId": 40,
			"enabled": true
		},
		{
			"name": "ArmillaryEffect",
			"start": 79.3825,
			"end": 82.28125,
			"layer": 3,
			"effectId": 44,
			"enabled": true
		}
	]
}